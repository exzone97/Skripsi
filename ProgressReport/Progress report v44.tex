\documentclass[a4paper,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[bahasa]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{float}
\usepackage[cm]{fullpage}
\pagestyle{myheadings}
\usepackage{etoolbox}
\usepackage{setspace} 
\usepackage{lipsum} 
\setlength{\headsep}{30pt}
\usepackage[inner=2cm,outer=2.5cm,top=2.5cm,bottom=2cm]{geometry} %margin
% \pagestyle{empty}
\usepackage{booktabs}

\makeatletter
\renewcommand{\@maketitle} {\begin{center} {\LARGE \textbf{ \textsc{\@title}} \par} \bigskip {\large \textbf{\textsc{\@author}} }\end{center} }
\renewcommand{\thispagestyle}[1]{}
\markright{\textbf{\textsc{Laporan Perkembangan Pengerjaan Skripsi\textemdash Sem. Ganjil 2018/2019}}}

\onehalfspacing
 
\begin{document}

\title{\@judultopik}
\author{\nama \textendash \@npm} 

%ISILAH DATA BERIKUT INI:
\newcommand{\nama}{Jonathan Alva}
\newcommand{\@npm}{2015730047}
\newcommand{\tanggal}{17/11/2018} %Tanggal pembuatan dokumen
\newcommand{\@judultopik}{Pengembangan Aplikasi Transfer Data Di WSN} % Judul/topik anda
\newcommand{\kodetopik}{ELH4502}
\newcommand{\jumpemb}{1} % Jumlah pembimbing, 1 atau 2
\newcommand{\pembA}{Elisati Hulu}
\newcommand{\pembB}{-}
\newcommand{\semesterPertama}{45 - Ganjil 18/19} % semester pertama kali topik diambil, angka 1 dimulai dari sem Ganjil 96/97
\newcommand{\lamaSkripsi}{1} % Jumlah semester untuk mengerjakan skripsi s.d. dokumen ini dibuat
\newcommand{\kulPertama}{Skripsi 1} % Kuliah dimana topik ini diambil pertama kali
\newcommand{\tipePR}{B} % tipe progress report :
% A : dokumen pendukung untuk pengambilan ke-2 di Skripsi 1
% B : dokumen untuk reviewer pada presentasi dan review Skripsi 1
% C : dokumen pendukung untuk pengambilan ke-2 di Skripsi 2

% Dokumen hasil template ini harus dicetak bolak-balik !!!!

\maketitle

\pagenumbering{arabic}

\section{Data Skripsi} %TIDAK PERLU MENGUBAH BAGIAN INI !!!
Pembimbing utama/tunggal: {\bf \pembA}\\
Pembimbing pendamping: {\bf \pembB}\\
Kode Topik : {\bf \kodetopik}\\
Topik ini sudah dikerjakan selama : {\bf \lamaSkripsi} semester\\
Pengambilan pertama kali topik ini pada : Semester {\bf \semesterPertama} \\
Pengambilan pertama kali topik ini di kuliah : {\bf \kulPertama} \\
Tipe Laporan : {\bf \tipePR} -
\ifdefstring{\tipePR}{A}{
			Dokumen pendukung untuk {\BF pengambilan ke-2 di Skripsi 1} }
		{
		\ifdefstring{\tipePR}{B} {
				Dokumen untuk reviewer pada presentasi dan {\bf review Skripsi 1}}
			{	Dokumen pendukung untuk {\bf pengambilan ke-2 di Skripsi 2}}
		}
		
\section{Latar Belakang}
\textit{Wireless Sensor Network} (WSN) adalah suatu jaringan nirkabel yang terdiri dari kumpulan node sensor dengan kemampuan \textit{sensing}, komputasi, dan komunikasi yang tersebar pada suatu tempat. Setiap sensor akan mengumpulkan data dari area yang dideteksi seperti temperatur, suara, getaran, tekanan, gerakan, kelembaban udara dan deteksi lainnya tergantung kemampuan sensor tersebut. Data yang diterima ini kemudian akan diteruskan ke \textit{base station} untuk diolah sehingga memberikan suatu informasi. WSN dapat diimplementasikan pada berbagai bidang kehidupan manusia diantaranya bidang militer untuk deteksi musuh, bidang pertanian untuk pemantauan pertumbuhan tanaman, bidang kesehatan, deteksi bahaya dan bencana alam, bidang pembangunan dan tata kota, dan bidang pendidikan.

Terdapat dua macam arsitektur WSN, yaitu hierarki dan flat. Pada arsitektur hierarki, node sensor akan disusun secara berkelompok (\textit{cluster}) dan terdapat node sensor yang memiliki peran sebagai \textit{cluster head}. \textit{Cluster head} berfungsi untuk mengumpulkan data dari node sensor pada suatu \textit{cluster} dan mengirimkan data tersebut ke \textit{base station}. Sedangkan pada arsitektur flat hanya terdapat dua macam node sensor secara fungsional, yaitu \textit{source node} dan \textit{sink node}. Setiap node sensor (\textit{source node}) akan mengirim data ke satu tujuan akhir yaitu \textit{sink node} atau \textit{base station}. Pada arsitektur flat data dari sebuah node sensor dapat diteruskan ke node tetangganya dan seterusnya hingga sampai ke \textit{base station}.

Dalam praktiknya, pengiriman data merupakan suatu hal yang penting pada WSN. Data yang didapat dari sensor harus sampai ke \textit{base station} dengan akurat dan utuh (\textit{reliable}). Data yang \textit{reliable} ini sangat penting karena hasil pengukuran dan tindakan selanjutnya yang akan diambil akan bergantung pada data-data tersebut. Terdapat beberapa protokol untuk memastikan transfer data \textit{reliable} yaitu dengan protokol \textit{Event to Sink Reliable Transport},\textit{Reliable Multi Segment Transport}, \textit{Price Oriented Reliable Transport}, \textit{Delay Sensitive Transport}, dan lain-lain.

Pada skripsi ini dibangun aplikasi untuk transfer data pada WSN. Aplikasi WSN yang dibuat juga dapat melakukan transfer data ke node sensor tetangganya hingga sampai ke node sensor yang berperan sebagai \textit{base station}. Karena data yang akurat sangat dibutuhkan untuk menentukan tindakan selanjutnya, maka akan dibangun juga WSN yang memiliki sifat \textit{reliable}.

\section{Rumusan Masalah}
\begin{itemize}
	\item Bagaimana cara membangun aplikasi transfer data dari setiap node sensor pada \textit{Wireless Sensor Network}?
	\item Bagaimana cara membangun aplikasi transfer data yang \textit{reliable} pada \textit{Wireless Sensor Network}?
\end{itemize}

\section{Tujuan}
\begin{itemize}
 	\item Membangun aplikasi transfer data yang \textit{reliable} pada \textit{Wireless Sensor Network}.
\end{itemize}	

\section{Detail Perkembangan Pengerjaan Skripsi}
Detail bagian pekerjaan skripsi sesuai dengan rencana kerja/laporan perkembangan terkahir :
	\begin{enumerate}
		\item \textbf{Mempelajari permasalahan dari topik skripsi ini.}\\
		{\bf Status :} Ada sejak rencana kerja skripsi.\\
		{\bf Hasil :} 
		
		Topik skripsi ini adalah Pengembangan Aplikasi Transfer Data di WSN, maka beberapa hal yang harus dipelajari oleh penulis adalah tentang WSN dan bagaimana cara membangun aplikasi untuk transfer data pada WSN termasuk melakukan analisa terkait dengan arsitektur digunakan.
		
		\item \textbf{Melakukan studi literartur mengenai \textit{Wireless Sensor Network}.}\\
		{\bf Status :} Ada sejak rencana kerja skripsi.\\
		{\bf Hasil :} 

\textbf{Wireless Sensor Network}
		
\textit{Wireless Sensor Network} (WSN) merupakan jaringan nirkabel yang terdiri dari sekumpulan node sensor yang diletakan pada suatu tempat dan memiliki kemampuan untuk mengukur kondisi lingkungan sekitar(\textit{sensing}), melakukan komputasi dan dilengkapi dengan alat komunikasi \textit{wireless} untuk komunikasi antara node sensor. Sensor ini akan mengumpulkan data dari kondisi lingkungannya, seperti: cahaya, suara, kelembapan, getaran, gerakan, temperatur, tekanan udara, kualitas air, komposisi tanah, dan lain-lain. Data ini kemudian dapat dikirimkan langsung ke \textit{base station} atau diteruskan melalui node sensor tetangganya hingga sampai ke \textit{base station} sebagai pusat untuk dikelola.

\textbf{Penerapan Wireless Sensor Network}

Pada awalnya \textit{sensor network} (jaringan sensor) digunakan dalam teknologi militer untuk mendeteksi musuh di laut dan di darat. Lama kelamaan node sensor ini banyak dikembangkan untuk membantu berbagai bidang kehidupan manusia. Pemanfaatan WSN pada kehidupan manusia dapat dilihat pada ilustrasi Gambar \ref{fig:smartworld}. Berikut adalah beberapa penerapan WSN:

\begin{itemize}
\item Bidang Militer\\
Pada bidang militer WSN digunakan untuk melakukan pemantauan musuh dan melindungi wilayah. WSN juga dapat digunakan untuk mendeteksi serangan dari musuh.

\item Monitoring area\\
Pada \textit{monitoring area}, node sensor akan disebar pada suatu tempat yang akan di monitoring. Saat node sensor mendeteksi kejadian(panas, tekanan, dan lain-lain) pada suatu tempat, data akan dikirimkan ke \textit{base station} untuk ditentukan tindakan selanjutnya.

\item Bidang Transportasi\\
Pada bidang transportasi, WSN digunakan untuk mendeteksi arus lalu lintas secara aktual yang nantinya akan disampaikan kepada pengendara seperti kemacetan lalu lintas. 

\item Bidang Kesehatan\\
WSN dapat digunakan pada aplikasi kesehatan seperti membantu pada disabilitas, monitoring pasien, diagnosis, pengaturan penggunaan obat, dan pelacakan dokter dan pasien di rumah sakit.

\item Deteksi Lingkungan\\
Deteksi lingkungan yang dapat dilakuan antara lain deteksi gunung berapi, polusi udara, kebakaran hutan, efek rumah kaca, dan deteksi longsor.

\item Monitoring Struktur\\
WSN dapat melakukan deteksi pergerakan bangunan dan infrastruktur seperti jembatan, \textit{flyover}, terowongan dan fasilitas lain tanpa mengeluarkan biaya untuk melakukan dektesi manual dengan mendatangi tempatnya secara langsung.

\item Bidang Pertanian\\
Pada bidang pertanian dapat membantu pengelola pertanian untuk pemantauan penggunaan air dalam irigasi dan mengelola buangan pertanian mereka.
\end{itemize}

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.3]{Gambar/smartworld}  
	\caption[Ilustrasi Pemanfaatan \textit{Wireless Sensor Network}]{Ilustrasi Pemanfaatan \textit{Wireless Sensor Network}} 
	\label{fig:smartworld} 
\end{figure} 

\textbf{Node Sensor}

\begin{itemize}
\item \textbf{Struktur Node Sensor}
\end{itemize}
Setiap node sensor memiliki kemampuan deteksi, komputasi dan komunikasi. Node sensor memiliki lima komponen utama yaitu \textit{controller}, \textit{memory}, sensor dan aktuator, \textit{communication device}, dan \textit{power supply} (Gambar \ref{fig:structure_sensor_node}). Semua komponen akan bekerja secara seimbang dalam melakukan \textit{sensing}, komputasi, komunikasi, dan menjaga penggunaan energi seminimal mungkin. 

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.3]{Gambar/structure_sensor_node}  
	\caption[Struktur Node Sensor]{Struktur Node Sensor} 
	\label{fig:structure_sensor_node} 
\end{figure}

\begin{itemize}
\item \textbf{Controller}

\textit{Controller} adalah inti utama pada node sensor. \textit{Controller} mengumpulkan data dari sensor dan memproses data tersebut hingga menentukan kapan dan kemana data tersebut dikirim. \textit{Controller} menerima data dari node sensor lain. Pada \textit{controller} biasanya terdapat \textit{microcontroller} atau \textit{microprocessor} yang mengatur dan melakukan komputasi data dari node sensor. \textit{Microcontroller} ini juga dapat mengurangi penggunaan energi dengan adanya \textit{sleep states} yang berarti hanya bagian dari controller saja yang aktif.

Beberapa \textit{microcontroller} yang digunakan dalam \textit{Wireless Sensor Node}:
\begin{itemize}
	\item Intel StrongARM (32-bit RISC, up to 206 MHz)
	\item Texas Instrument MSP 430 (16-bit RISC, up to 4 MHz,RAM 2-10 kB)
	\item Atmel Atmega 128L (8-bit)
\end{itemize}	
\end{itemize}
\begin{itemize}
\item \textbf{Memory}

\textit{Random Access Memory} (RAM) digunakan untuk menyimpan sementara hasil yang didapat dari sensor. RAM juga menyimpan sementara paket dari node sensor lain. Jika node sensor mati atau energi habis maka data pada RAM ini akan hilang. Data yang hilang saat node sensor mati merupakan salah satu kekurangan dari penggunaan RAM. Untuk itu dalam menyimpan kode program digunakanlah \textit{Read Only Memory} (ROM). ROM ini biasa disebut \textit{Electrically Erasable Programmable Read-Only Memory} (EEPROM) atau \textit{Flash Memory}.
\end{itemize}

\begin{itemize}
\item \textbf{Communication Device}

\textit{Communication Device} digunakan untuk bertukar data antar node sensor. Pada aplikasi WSN, \textit{Radio Frequency(RF)} adalah media komunikasi yang paling relevan untuk saat ini. RF-based mendukung jangkauan yang jauh, memiliki data rate yang tinggi dan tidak perlu saling mengetahui posisi antara penerima dan pengirim.
\\
Pada node sensor dibutuhkan \textit{transmitter} untuk mengirim data dan \textit{receiver} untuk menerima data. Kedua hal ini dapat digabung dan disebut dengan \textit{transceiver}. Tugas \textit{transceiver} adalah mengubah aliran \textit{bit} menjadi gelombang radio. Selain itu \textit{transceiver} juga dapat mengubah gelombang radio menjadi aliran \textit{bit}.
\end{itemize}

\begin{itemize}
\item \textbf{Sensor dan Aktuator}

Sensor dan Aktuator adalah hal yang penting pada WSN. Tanpa sensor dan aktuator maka node sensor tidak berguna dan tidak dapat digunakan. Tabel \ref{tab:sensor} adalah jenis - jenis sensor yang dapat dimiliki node sensor. Sensor dikategorikan menjadi tiga:
\begin{enumerate}
	\item \textbf{Passive, omnidirectional sensors} Sensor ini dapat mengukur kualitas dari lingkungan fisik tempat node sensor tersebut tanpa mengubah lingkungannya. Beberapa sensor dikategori ini \textit{self-powered} yaitu sensor mendapatkan energi yang mereka butuhkan dari lingkungannya. \textit{Omnidirectional} berarti tidak ada arah pada sensor ini. Sensor akan memancarkan sinyalnya ke segala arah. Contoh sensor ini adalah termometer, sensor cahaya, sensor getaran, mikrofon, sensor kelembapan, sensor tekanan udara, sensor deteksi asap, dan lain-lain.
	\item \textbf{Passive, narrow-beam sensors} Sensor ini memiliki sifat yang sama dengan sensor \textit{Passive, omnidirectional sensors} yaitu tidak mengubah lingkungannya. Sensor ini dapat melakukan gerakan dan memiliki arah atau daerah pengukuran. Contoh dari sensor ini adalah kamera yang bisa mengukur sesuai dengan arah yang dituju.
	\item \textbf{Active Sensor} Sensor ini aktif dalam memeriksa lingkungannya. Contoh dari sensor ini adalah sonar, radar atau sensor seismik. Sensor ini menghasilkan gelombang untuk melakukan deteksi.
\end{enumerate}

Aktuator adalah penerima sinyal dan yang mengubahnya menjadi aksi fisik. Aktuator jumlahnya beragam seperti sensor.  Contoh aktuator adalah LED, yang mengubah listrik menjadi cahaya dan motor (motor elektrik) juga mengubah listrik menjadi gerakan.

\begin{table} [H]
	\centering 
	\caption{Jenis - jenis sensor yang dapat dimiliki node sensor}
	\label{tab:sensor}
	\begin{tabular}{|p{5.5cm}|p{7cm}|}
		\toprule
		Sensor & Penggunaan\\

		\midrule
		Accelerometer & Pergerakan 2D \& 3D untuk objek dan manusia  \\
		Acoustic emission sensor & Elastic Waves Generation\\
		Acoustic sensor   & Acoustic pressure vibration\\
		Capacitance sensor  & Solute Concentration\\
		ECG   & Heart Rate\\
		EEG  & Brain Electric Activity\\
		EMG   & Muscle Activity\\
		Electrical/electromagnetic sensor & Electrical Resistivity\\
		Gyroscope  & Angular Velocity \\
		Humidity Sensor   & Mendeteksi Humidity\\
		Infrasonic sensor  &  Gelombang untuk deteksi gempa dan volkanik\\
		Magnetic sensor   & Mendeteksi magnetik\\
		Oximeter   & Tekanan Oxigenation pada darah  \\
		pH sensor  & Tingkat Keasaman\\
		Photo acoustic spectroscopy   & Gas Sensing\\
		Piezoelectric cylinder    &  Gas Velocity\\
		Soil moisture sensor   &  Mengukur tanah\\
		Temperature sensor   & Temperatur \\
		Barometer sensor  &  tekanan air\\
		Passive infrared sensor  & Pergerakan infrared\\
		Seismic sensor   & Pergerakan Seismik (Gempa) \\
		Oxygen sensor  & Oksigen pada darah \\
		Blood flow sensor  & Gelombang ultrasonik pada darah \\

		\bottomrule
		
	\end{tabular} 
\end{table}
\end{itemize}

\begin{itemize}
\item \textbf{Power Supply}

\textit{Power supply} atau sumber energi pada WSN dapat berasal dari dua cara yaitu \textbf{\textit{storing energy}} dan \textbf{\textit{energy scavenging}}. \textit{Storing energy} adalah dengan menggunakan baterai sebagai sumber energinya. Baterai yang digunakan dapat diisi ulang maupun tidak dapat diisi ulang. \textit{Energy scavenging} digunakan saat membuat WSN yang akan digunakan dalam waktu yang lama. Dibutuhkan energi yang bisa dikatakan tidak terbatas. Salah satu cara \textit{energy scavenging} adalah \textit{photovoltaics}. \textit{Photovoltaics} dapat disebut juga \textit{solar cell} yang memanfaatkan cahaya matahari dan mengubahnya menjadi energi sebagai pembangkit daya. Cara lain yang dapat digunakan adalah pemanfaatan angin dan air untuk mengerakan kincir atau turbin yang akan menghasilkan listrik dan digunakan sebagai sumber energi pada node sensor.
\end{itemize}
		
\textbf{Arsitektur dan Topologi}
		
		Pada WSN biasanya akan terdapat banyak node sensor yang disebar pada suatu tempat. Terdapat satu atau lebih \textit{sink node} atau \textit{base station} dalam area sensing tersebut (Gambar~\ref{fig:arsitektur}). \textit{Sink node} atau \textit{base station} adalah node sensor yang bertugas untuk mendapatkan data dari node sensor lain. Dalam membuat WSN perlu diperhatikan arsitektur dan topologi yang akan digunakan. Tidak semua topologi jaringan komputer dapat digunakan untuk \textit{Wireless Sensor Network}. 

Ada banyak topologi pada jaringan sensor (\textit{sensor network}). Pada jaringan sensor dengan menggunakan kabel, topologi yang sering digunakan adalah topologi \textit{star}, \textit{line}, atau \textit{bus}. Sedangkan pada jaringan sensor tanpa kabel (WSN), topologi yang biasa digunakan adalah \textit{star}, \textit{tree}, atau \textit{mesh}. 

\begin{itemize}
\item \textbf{Topologi Point-to-Point}

Topologi \textit{Point-to-Point} adalah topologi yang menghubungkan dua titik (Gambar \ref{fig:point2point}). Topologi \textit{Point-to-Point} dibagi menjadi dua yaitu \textit{permanent point-to-point} dan \textit{switched point-to-point}. \textit{Permanent point-to-point} adalah koneksi perangkat keras antara dua titik dan tidak dapat diubah. \textit{Switched point-to-point} adalah koneksi \textit{point-to-point} yang dapat berpindah antara node yang berbeda. 
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.6]{Gambar/point2point}  
	\caption[Topologi Point-to-Point]{Topologi Point-to-Point} 
	\label{fig:point2point} 
\end{figure}

\item \textbf{Topologi Bus}

Topologi \textit{Bus} seperti pada Gambar \ref{fig:bus} akan terdiri dari node-node dan sebuah jalur. Setiap node akan terhubung dengan saatu jalur yang sama. Untuk mengirim data atau komunikasi akan dilakukan bergantian antar node. Kekurangan dari topologi \textit{bus} ini adalah jika suatu saat jalur atau bus ini mengalami kerusakan maka setiap node tidak dapat saling berkomunikasi lagi.
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.2]{Gambar/bus}  
	\caption[Topologi Bus]{Topologi Bus} 
	\label{fig:bus} 
\end{figure} 

\item \textbf{Topologi Ring}

Pada Topologi \textit{Ring} node akan disusun dengan bentuk melingkar (Gambar \ref{fig:ring}). Setiap node akan terkoneksi dengan dua node lain. Transfer data terjadi dengan cara data akan berjalan dari satu node ke node lain mengikuti jalur melingkar tersebut hingga menemukan node tujuan yang tepat. Topologi ini mudah untuk diimplementasikan tapi kekurangan dari topologi ring adalah saat ada node yang rusak maka perlu biaya lebih untuk memperbaikinya. Biasanya untuk menangani kegagalan komunikasi akibat node yang rusak, akan di atur komunikasi node tidak hanya satu arah tetapi dapat ke arah sebaliknya.
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.3]{Gambar/ring}  
	\caption[Topologi Ring]{Topologi Ring} 
	\label{fig:ring} 
\end{figure} 

\item \textbf{Topologi Star}

Topologi \textit{Star} terdiri dari satu node yang berada di tengah biasanya berupa \textit{hub} atau \textit{switch} seperti pada Gambar~\ref{fig:star}. Setiap node akan terkoneksi dengan node yang berada di tengah ini. Saat node akan berkomunikasi dengan node lain, node tersebut harus mengirimkan data tersebut ke node yang ada ditengah dahulu dan node yang berada ditengah ini akan meneruskan data tersebut ke node tujuan. Yang paling penting pada topologi ini adalah node yang berada di tengah, karena semua komunikasi harus melalui node tersebut. Jika node tengah mengalami kerusakan maka tidak akan terjadi komunikasi antar node pada jaringan tersebut.
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.3]{Gambar/star}  
	\caption[Topologi Star]{Topologi Star} 
	\label{fig:star} 
\end{figure} 

\item \textbf{Topologi Tree}

Pada Topologi \textit{Tree} node-node akan disusun secara hierarki dengan satu node yang berada pada level paling atas sebagai \textit{root node} (Gambar~\ref{fig:tree}). \textit{Root node} akan terhubung dengan satu atau lebih node level dibawahnya. Dengan Topologi \textit{Tree} lebih mudah untuk melakukan identifikasi dan meminimalisir kesalahan, namun jika \textit{tree} sudah sangat besar atau \textit{level tree} sudah sangat banyak maka akan sulit untuk melakukan konfigurasi.
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.3]{Gambar/tree}  
	\caption[Topologi Tree]{Topologi Tree} 
	\label{fig:tree} 
\end{figure} 

\item \textbf{Topologi Mesh}

Topologi \textit{Mesh} dibagi menjadi dua yaitu \textit{partially connected mesh} dan \textit{fully connected mesh}. Pada \textit{partially connected mesh} (Gambar~\ref{fig:mesh_partial}), node akan terhubung dengan lebih dari satu node. Pada \textit{fully connected mesh} (Gambar~\ref{fig:mesh_fully}), setiap node akan terhubung dengan semua node lain pada jaringan tersebut.
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.07]{Gambar/mesh_partial}  
	\caption[Topologi Partially Connected Mesh]{Topologi Partially Connected Mesh} 
	\label{fig:mesh_partial} 
\end{figure} 
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.07]{Gambar/mesh_fully}  
	\caption[Topologi Fully Connected Mesh]{Topologi Fully Connected Mesh} 
	\label{fig:mesh_fully} 
\end{figure}

Arsitektur yang biasanya dipakai pada WSN adalah \textbf{arsitektur flat atau peer-to-peer} dan \textbf{arsitektur hierarki}. Selain itu dalam membangun WSN perlu juga diperhatikan jalur komunikasi yang digunakan untuk menghubungkan antar node sensor saat transfer data. Untuk area \textit{sensing} yang tidak terlalu luas dan hanya menggunakan sedikit node sensor dapat menggunakan cara komunikasi \textbf{\textit{single hop}}. Sedangkan untuk daerah yang luas dan memerlukan banyak node sensor dapat menggunakan cara komunikasi \textbf{\textit{multi hop}}. 

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/arsitektur}  
	\caption[Arsitektur Wireless Sensor Network]{Arsitektur Wireless Sensor Network} 
	\label{fig:arsitektur} 
\end{figure} 

\item \textbf{Single-Hop dan Multi-Hop}

Untuk mengirim data ke \textit{sink node} setiap node sensor dapat menggunakan \textit{single-hop long-distance transmission}. \textit{Single-hop long-distance} ini berarti setiap node sensor akan mengirimkan data ke sink node hanya satu kali lompatan walaupun jarak antara sink node dengan node sensor itu sangat jauh. Dalam jaringan sensor, penggunaan energi paling besar adalah saat melakukan komunikasi dibandingan saat sensing. Penggunaan energi akan semakin bertambah jika jarak sink dan node sensor semakin jauh. Untuk menangani masalah tersebut muncul protokol \textit{multi-hop}.

Pada protokol \textit{multi-hop}, node sensor akan disusun saling berdekatan dan terhubung dengan yang lain. Jadi saat akan berkomunikasi dengan \textit{sink node}, node sensor harus mengirimkan data tersebut ke node sensor tetangganya dan diteruskan hingga sampai ke \textit{sink node}. Karena jarak yang saling berdekatan maka penggunaan energi dapat efektif. \textit{Single-hop} dan \textit{multi-hop} ini dapat digunakan pada topologi flat maupun hierarki sesuai dengan kebutuhan sistem.

\item \textbf{Arsitektur Flat / Peer-to-Peer}

Pada arsitektur flat, setiap node sensor memiliki peran atau \textit{role} yang sama dalam melakukan \textit{sensing}. Secara fungsional hanya terdapat dua macam node sensor pada arsitektur flat, yaitu \textit{source node} dan \textit{sink node}. Untuk mendapatkan data dilakukan dengan cara \textit{sink node} melakukan pengiriman data ke semua node sensor pada area \textit{sensing} dengan cara \textit{flooding} dan hanya node sensor yang sesuai yang akan merespon \textit{sink node}. Setiap node sensor mengirimkan data ke \textit{sink node} dengan \textit{multi hop} dan melalui node tetangganya yang terhubung dengannya untuk meneruskan data (Gambar~\ref{fig:flat}).
% gambar flat
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.6]{Gambar/flat}  
	\caption[Arsitektur flat pada \textit{Wireless Sensor Network}]{Arsitektur flat pada \textit{Wireless Sensor Network}} 
	\label{fig:flat} 
\end{figure} 

\item \textbf{Arsitektur Hierarki}

Pada arsitektur hierarki, semua node sensor dikelompokan ke dalam cluster-cluster. Terdapat \textit{cluster head} pada setiap cluster. \textit{Cluster head} ini yang mengumpulkan data dari setiap node sensor di bawahnya dan meneruskan data yang telah diterima ke \textit{base station} atau \textit{sink node}. Hal yang perlu diperhatikan pada arsitektur hierarki adalah pemilihan node sensor sebagai \textit{cluster head} dan node sensor yang melakukan sensing. Penggunaan energi yang paling besar dalam WSN ini adalah saat melakukan komunikasi yaitu saat mengirimkan data ke node sensor lain. Maka untuk node sensor yang memiliki energi kecil dapat digunakan untuk \textit{sensing}, karena node sensor ini hanya melakukan komunikasi ke \textit{cluster head}. \textit{Cluster head} harus memiliki energi atau daya yang lebih banyak, karena \textit{cluster head} akan bertugas menerima hasil sensing node sensor di bawahnya dan meneruskan data ke \textit{sink node}. 

Masalah yang utama pada clustering ini adalah pemilihan \textit{cluster head} dan bagaimana cara mengatur setiap cluster. Terdapat beberapa cara untuk membuat clustering ini. Bedasarkan jarak antara \textit{cluster head} dengan cluster member, dapat dibuat clustering dengan \textit{single-hop} atau \textit{multi-hop} seperti pada Gambar~\ref{fig:cluster_single} dan Gambar~\ref{fig:cluster_multi}. Sedangkan jika berdasarkan jumlah \textit{tier} atau tingkat dapat dibangun \textit{clustering single tier} atau \textit{multi tier} (Gambar~\ref{fig:cluster_multitier}).
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/cluster_single}  
	\caption[Arsitektur hierarki pada \textit{Wireless Sensor Network} dengan \textit{single hop} terhadap \textit{Cluster Head}]{Arsitektur hierarki pada \textit{Wireless Sensor Network} dengan \textit{single hop} terhadap \textit{Cluster Head}} 
	\label{fig:cluster_single} 
\end{figure} 
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/cluster_multi}  
	\caption[Arsitektur hierarki pada \textit{Wireless Sensor Network} dengan \textit{multi hop}]{Arsitektur hierarki pada \textit{Wireless Sensor Network} dengan \textit{multi hop}} 
	\label{fig:cluster_multi} 
\end{figure} 
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/cluster_multitier}  
	\caption[Clsutering dengan multi tier]{Clustering dengan multi tier} 
	\label{fig:cluster_multitier} 
\end{figure}

		\end{itemize}
		
\textbf{Sistem Operasi}
		
		Setiap node sensor memerlukan sistem operasi (OS) untuk mengontrol perangkat keras dan perangkat lunak. Sistem operasi tradisional tidak dapat digunakan pada WSN. Pada sistem operasi tradisional digunakan untuk mengatur proses, memori, CPU, dan sistem berkas. Terdapat beberapa hal yang harus ditangani oleh sistem operasi dalam WSN yaitu:
\begin{itemize}
	\item WSN memerlukan \textit{real-time scheduler}. Data yang didapat harus segera dikirim atau diproses.
	\item Pengaturan memori karena memori pada WSN sangat kecil.
	\item Pengaturan data yang efisien terkait dengan \textit{microprocessor} dan memori yang terbatas
	\item Mendukung kode pemrograman yang efisien dan \textit{reliable} karena dapat terjadi perubahan kode saat implementasi.
	\item Mendukung pengaturan sumber daya untuk menambah waktu hidup dari node sensor dan meningkatkan performa dengan \textit{sleep time} saat tidak ada kegiatan atau \textit{wake up time} saat terdapat interupsi dari lingkungan.
	\item Mendukung antarmuka untuk pemrograman dan antarmuka perangkat lunak. 
\end{itemize}

Beberapa sistem operasi yang umum digunakan pada WSN antara lain :
\begin{enumerate}
	\item TinyOS
	\item Contiki
	\item LiteOS
	\item PreonVM
	
\end{enumerate}
		
		\textbf{TinyOS} adalah sistem operasi \textit{open-source} yang digunakan pada WSN. TinyOS dapat menjalankan program dengan memori yang sangat kecil. Ukurannya hanya 400 Byte. Komponen \textit{library} TinyOS terdiri dari protokol jaringan, layanan distribusi sensor, \textit{driver sensor}, dan perangkat lunak pengamatan data sensor yang dapat digunakan untuk melakukan monitoring jaringan sensor. Gambar~\ref{fig:tinyOS} adalah arsitektur pada TinyOS. 
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/tinyOS}  
	\caption[Arsitektur TinyOS]{Arsitektur TinyOS} 
	\label{fig:tinyOS} 
\end{figure}

\textbf{Contiki} adalah sistem operasi \textit{open-source} dengan Bahasa Pemrograman C yang digunakan pada WSN. Pengaturan Contiki hanya memerlukan 2KB dari RAM dan 40KB dari ROM. Fitur yang dimiliki oleh Contiki antara lain: \textit{multitasking}, \textit{multithreading}, jaringan TCP/IP, IPv6, GUI, \textit{Web Browser}, \textit{Web Server}, telnet, dan komputasi jaringan virtual. Gambar~\ref{fig:contiki} adalah arsitektur pada Contiki
\begin{figure} [H]
	\centering  
	\includegraphics[scale=3]{Gambar/contiki}  
	\caption[Arsitektur Contiki]{Arsitektur Contiki} 
	\label{fig:contiki} 
\end{figure}

\textbf{LiteOS} adalah sistem operasi mirip UNIX yang didisain untuk WSN. Tujuan dibuat LiteOS adalah membuat sistem operasi yang mirip dengan UNIX agar lebih lebih familiar dengan paradigma pemrograman UNIX. Pada LiteOS terdapat sistem berkas yang hiearki, dan mendukung Bahasa Pemrograman LiteC++ dan UNIX Shell. LiteOS dapat digunakan untuk MicaZ yang memiliki 8 Mhz CPU, 128 byte flash, dan 4KB RAM. LiteOS memiliki tiga komponen utama yaitu: LiteShell, LiteFS, dan Kernel. Gambar~\ref{fig:contiki} adalah arsitektur pada LiteOS
\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.4]{Gambar/liteOS}  
	\caption[Arsitektur LiteOS]{Arsitektur LiteOS} 
	\label{fig:liteOS} 
\end{figure}

Perbandingan dari TinyOS, Contiki, dan LiteOS dapat dilihat pada Tabel~\ref{tab:perbandinganOS} berikut ini:
\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\caption{Tabel Perbandingan Sistem Operasi}
	\label{tab:perbandinganOS}
	\begin{tabular}{| p{1.6cm} | p{3.8cm} | p{2.5cm} | p{3cm} | p{4cm} |}
		\toprule
		OS & Programming Paradigm & Scheduling & Memory Allocation & System Call\\ 
		
		\midrule
		TinyOS & Event-based & FIFO & Static & Not Available\\
		Contiki & Predominant event-based & FIFO & Dynamic & Runtime libraries\\ 
		LiteOS & Thread-based & Priority-based scheduling with optional round-robin support & Dynamic & A host of system calls available to the user (file, process, environment, debugging, and device command) 	\\ 

		\bottomrule
		
	\end{tabular} 
\end{table}

\textbf{Protokol Stack pada Wireless Sensor Network}

WSN memiliki lima layer protokol: physical layer, data link layer, network layer, transport layer, dan application layer, seperti pada Gambar \ref{fig:layer}. 

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.5]{Gambar/layer}  
	\caption[Layer pada \textit{Wireless Sensor Network}]{Layer pada \textit{Wireless Sensor Network}} 
	\label{fig:layer} 
\end{figure} 

Selain itu protokol stack pada WSN dibagi kedalam 3 grup manajemen yaitu \textit{power management plane}, \textit{connection management plane}, dan \textit{task management plane}. \textbf{\textit{Power Management Plane}} bertanggung jawab untuk melakukan manajemen sumber daya atau energi pada setiap node sensor saat melakukan sensing, processing, transfer data dan menerima data. Contohnya pada layer MAC, node sensor dapat mematikan transceiver saat tidak ada data untuk dikirim dan diterima. Pada \textit{network layer}, node sensor dapat memilih node sensor tetangga saat akan melakukan transfer data agar penggunaan energi yang minimal. \textbf{\textit{Connection Management Plane}} bertanggung jawab untuk melakukan pengaturan terhadap node sensor terkait dengan koneksi antar node sensor. \textbf{\textit{Task Management Plane}} bertanggung jawab untuk mengatur distribusi tugas atau \textit{task} pada node sensor dalam melakukan \textit{sensing} agar tercapai penggunaan energi yang efisien.

\begin{itemize}
\item \textbf{Physical layer}
\end{itemize}	

\textit{Physical layer} bertanggung jawab untuk mengubah bit stream dari data link layer menjadi sinyal agar bisa dilakukan transmisi melalui media komunikasi yang terdapat (transceiver). Pemilihan media dan frekuensi adalah hal yang penting dalam komunikasi antar node sensor. Salah satu cara yang bisa digunakan adalah dengan menggunakan \textit{Radio frequency} (RF). Jaringan sensor memerlukan biaya yang kecil, ukuran yang kecil, dan penggunaan daya yang kecil untuk tranceivernya. Karena itu banyak yang menggunakan Radio Frequency (RF) untuk desain perangkat keras node sensornya.

\begin{itemize}
\item \textbf{Data link layer}
\end{itemize}

\textit{Data link layer} bertanggung jawab untuk melakukan \textit{multiplexing} pada aliran data, membentuk data frame, mendeteksi data frame, \textit{medium access}, dan mengatur kesalahan saat transmisi data. Fungsi paling penting data link layer adalah \textit{Medium Access Control} (MAC). Protokol MAC menentukan kapan node sensor mengakses media untuk mengirim data, melakukan kontrol dan mengatur paket ke node sensor lain. Hal itu dilakukan agar tidak terjadi paket yang bertabrakan.


\begin{itemize}
\item \textbf{Network layer}
\end{itemize}

\textit{Network layer} bertanggung jawab untuk \textit{routing} dari node sensor ke \textit{sink node}. Pada WSN node sensor tersebar pada suatu tempat untuk melakukan \textit{sensing}. Data hasil \textit{sensing} tersebut harus dikirimkan ke \textit{sink node} untuk diolah. Dalam mengirimkan data tersebut dapat menggunakan \textit{single-hop} atau \textit{multi hop}. Dalam mengirim data diperlukan protokol routing yang tepat agar hemat energi.

\begin{itemize}
\item \textbf{Transport layer}
\end{itemize}

Secara umum \textit{transport layer} bertanggung jawab untuk pengiriman data yang \textit{reliable} antara node sensor dan \textit{sink node}. Protokol transpor yang biasa pada jaringan komputer tidak bisa diterapkan pada WSN tanpa modifikasi. Setiap jaringan sensor memiliki fungsi khusus. Untuk aplikasi yang berbeda memerlukan kebutuhkan reliabilitas yang berbeda. Pengiriman data pada WSN dibagi menjadi dua yaitu: \textbf{\textit{downstream}} dan \textbf{\textit{upstream}}. \textbf{\textit{Upstream}} berarti node sensor mengirimkan hasil sensing ke sink node. \textbf{\textit{Downstream}} berarti data berasal dari sink node contohnya, kueri, dan perintah-perintah yang dikirimkan ke setiap node sensor. Aliran data yang \textit{reliable} untuk kedua jenis pengiriman ini berbeda. Pada \textit{upstream}, \textit{reliable} data dapat ditoleransi karena sensor akan melakukan sensing terus menerus dan dapat terjadi pengulangan data sehingga data yang hilang tadi dapat dikoreksi. Sedangkan pada \textit{downstream} memerlukan 100\% pengiriman data yang \textit{reliable} karena aplikasi tidak dapat berjalan jika kode program tidak lengkap.

\begin{itemize}
\item \textbf{Application layer}
\end{itemize}

\textit{Application layer} meliputi berbagai macam protokol yang ada pada layer ini untuk menjalankan berbagai macam aplikasi seperti \textit{query dissemination}, \textit{node localization}, \textit{time synchronization}, dan \textit{network security}. Protokol yang ada pada layer ini antara lain:
\begin{enumerate}
	\item Sensor management protocol (SMP) adalah protokol untuk melakukan pertukaran lokasi data, sinkornisasi node sensor, mengatur ulang node sensor, dan menyimpan status dari node sensor.
	\item Sensor query and data dissemination protocol (SQDDP) adalah protokol yang mendukung antarmuka aplikasi untuk memasukan query, merespon query, dan mengumpulkan respon.
	\item Sensor query and tasking language (SQTL) adalah protokol untuk mendukung bahasa pemrograman pada WSN.
\end{enumerate}

		\item \textbf{Mempelajari protokol transfer data yang biasa pada \textit{Wireless Sensor Network}.}\\
		{\bf Status :} Ada sejak rencana kerja skripsi.\\
		{\bf Hasil :}
		
WSN terdiri dari \textit{sink node} dan banyak node sensor. Saat melakukan sensing dan mengirim data ke \textit{sink node}, semua node sensor akan mengirimkan data melalui media yang sama. Hal ini dapat membanjiri jaringan dengan data tersebut dan menyebabkan \textit{congestion} atau kemacetan pada jaringan yang berakibat \textit{data loss} atau hilang. Untuk menangani \textit{data loss}, maka salah satu yang diperlukan dalam membangun WSN adalah protokol yang menangani \textit{Reliability}. \textit{Reliability} berarti memastikan data yang dikirim dari setiap node sensor diterima oleh \textit{base station} secara lengkap dan sesuai dengan urutan pengiriman.

\textbf{Jenis Reliability}

Berdasarkan tingkat, reliability ada dua macam yaitu:
\begin{itemize}
	\item \textbf{Packet Reliability}
	
	Packet Reliability berarti paket yang dikirim harus sampai kepada tujuan (\textit{base station}) secara utuh. \textit{Packet reliability} ini membutuhkan \textit{acknowledge} dari node sensor. Tantangan yang harus dihadapi dari \textit{packet reliability} adalah dalam mengirim ulang paket yang hilang akan menghabiskan energi atau daya.	
		
	\item \textbf{Event Reliability}
	
	Event Reliability berarti hanya data hasil \textit{sensing} yang akan dikirim ke \textit{base station}. Pada \textit{Event reliability} tidak membutuhkan \textit{acknowledge}. Karena data yang hilang itu tidak banyak berpengaruh sehingga tidak dibutuhkan pengiriman ulang (\textit{retransmission}) data.
	
\end{itemize} 

Berdasarkan arah, \textit{reliability} ada dua macam yaitu:
\begin{itemize}
	\item \textbf{Upstream Reliability}
	
Upstream Reliability adalah komunikasi dari node sensor ke \textit{sink node}. Banyak protokol yang mendukung \textit{upstream reliability}. Pengiriman data yang dilakukan adalah \textit{unicast} yang berarti hanya dari satu titik ke titik lain.	
	
	\item \textbf{Downstream Reliability}
	
	Downstream Reliability adalah adalah komunikasi dari \textit{sink node} ke node sensor. Pengiriman data biasanya dilakukan dengan cara \textit{broadcast} ke semua node sensor. Data yang dikirim ini biasanya adalah kode program untuk melakukan \textit{sensing}. 
\end{itemize}

Pada protokol transport tradisional dikenal istilah TCP dan UDP, namun keduanya tidak bisa diimplementasikan pada WSN. Namun, protokol transport tersebut bisa dibuat dengan beberapa pertimbangan seperti:
\begin{itemize}
	\item WSN membutuhkan mekanisme untuk mengembalikan paket yang hilang seperti \textit{acknowledge}.
	\item Proses awal dalam membangun koneksi seperti \textit{handshake} harus disederhanakan karena akan membuang banyak daya atau energi.
	\item Protokol harus dapat menangani \textit{congestion}.
	\item Protokol harus dapat adil terhadap setiap node sensor seperti pembagian penggunaan jaringan. (\textit{bandwidth})
\end{itemize} 

\textit{Retransmission} dapat dilakukan dengan \textit{End-to-End Retransmission} dan \textit{Hop-by-Hop Retransmission (Link Level Retransmission)}. Pada \textbf{\textit{End-to-End transmission}} dan terjadi \textit{data loss}, maka pengirim harus mengirim ulang semua paket dan akan menghabiskan lebih banyak daya. \textit{End-to-End Retransmission} adalah salah satu metode yang digunakan di Internet. Cara ini dapat memastikan \textit{reliable} data tanpa harus mengetahui apa yang terjadi di tengah jaringan. Pada \textit{End-to-End Retransmission} diperlukan \textit{handshake} seperti pada komunikasi jaringan komputer. Pada awalnya data dikirim sebagai permintaan transfer. Jika penerima (\textit{receiver}) memiliki cukup RAM, dan layer aplikasi dapat menerima data tersebut, maka \textit{receiver} mengirimkan \textit{acknowledge} untuk permintaan data tersebut. Saat koneksi sudah terbentuk, data yang sebenarnya dapat dikirim. Data tersusun dari beberapa \textit{round}. Setiap \textit{round}, pengirim (\textit{sender}) mengirim paket yang hilang pada round sebelumnya. Diakhir setiap  round, \textit{receiver} mengirimkan \textit{acknowledge} kepada \textit{sender} yang berisi informasi paket yang hilang. \textit{Sender} menerima \textit{acknowledge} tersebut dan mengirim paket yang hilang tersebut. Untuk round pertama terdapat pengecualian karena semua pake pada round sebelumnya tidak ada (belum dikirim). 

Sedangkan pada \textbf{\textit{hop-by-hop transmission}} dilakukan antara node sensor dengan node sensor tetangganya. Jadi saat terjadi \textit{data loss} maka pengiriman ulang lebih sedikit dalam menghabiskan daya. \textit{Hop-by-hop} ini membutuhkan \textit{buffer} atau penyimpanan sementara pada setiap node sensor dan lebih efektif dilakukan pada topologi WSN \textit{multi-hop}. Buffer ini digunakan untuk menyimpan data sementara hingga mendapatkan \textit{acknowledge} dari hop berikutnya.

\textbf{Jenis - jenis Acknowledge}

Dalam mencapai reliability dapat digunakan acknowledge saat melakukan pengiriman data. Terdapat empat jenis acknowledge yang dapat digunakan, yaitu:
\begin{itemize}
	\item Explicit Acknowledge (eACK) : Penerima memberitahu pengirim bahwa paket telah diterima dengan tepat sekaligus memberitahu pengirim paket mana yang belum diterima untuk dilakukan \textit{retransmission}.
	\item Negative Acknowledge (nACK) : Penerima memberitahu pengirim bahwa paket yang diterima tidak benar dan diperlukan \textit{retransmission}.
	\item Implicit Acknowledge (iACK) : Setelah pengirim mengirim pesan, pengirim akan memastikan paket data dikirim ke tetangganya memberikan acknowledge.
	\item Selective Acknowledge (sACK) : Hanya paket yang hilang dari sebuah pesan yang akan dikirim ulang
\end{itemize}

\textbf{Protokol Transport yang Reliable}

Ada banyak protokol untuk memastikan \textit{reliability} pada WSN. Beberapa protokol mendukung \textit{upstream} dan beberapa protokol mendukung \textit{downstream}. Hanya ada sedikit protokol yang dapat mendukung keduanya. Selain itu ada protokol yang memiliki fokus utama untuk menangani \textit{reliability} saja dan ada yang menangani \textit{congestion} sekaligus \textit{reliability}. 

Beberapa protokol transport yang sering digunakan antara lain:
\begin{itemize}
	\item GARUDA
	\item Event-to-Sink Reliable Transport (ESRT)
	\item Reliable Multi Segment Transport (RMST)
	\item Pump Slowly Fetch Quickly (PSFQ)
	\item Asymmetric Reliable Transport (ART)
	\item Price Oriented Reliable Transport (PORT)
	\item Delay Sensitive Transport (DST)
\end{itemize}

\textbf{GARUDA}

GARUDA adalah salah satu protokol \textit{downstream} yang menggunakan \textit{hop-by-hop retransmission} dalam memastikan \textit{reliability}. Protokol ini dapat berjalan pada arsitektur dengan dua \textit{tier}. Node sensor dengan 3\i hop dari sink node akan dipilih menjadi node sensor inti (\textit{core}). Node sensor lain (\textit{noncore}) akan disebut dengan \textit{second-tier nodes}. Setiap node noncore menggunakan node \textit{core} untuk memulihkan paket yang hilang.  GARUDA menggunakan mekanisme NACK untuk mendeteksi paket yang hilang. Pemulihan paket yang hilang dilakukan dengan dua fase. Pemulihan paket dalam node \textit{core}, dan pemulihan paket antara node noncore dengan node core. 

GARUDA menggunakan mekanisme WFP \textit{(Wait for First Packet) pulse transmission} untuk memastikan keberhasilan dalam mengirim satu atau paket pertama. Pulse transmission ini juga digunakan untuk menghitung jumlah hop dan memilih core node. Kekurangan dari GARUDA adalah tidak dapat menangani \textit{upstream reliability} dan tidak menangani ]\textit{congestion control}.  

\textbf{Event-to-Sink Reliable Transport (ESRT)}

Pada WSN terdapat \textit{event detection}, yaitu saat node sensor mendeteksi sebuah \textit{event} pada sebuah radius tertentu. Hasil deteksi tersebut yang kemudian dikirimkan ke \textit{sink node}. Gambar~\ref{fig:event_detection} menunjukan \textit{event detection} pada WSN. Event-to-Sink Reliable Transport (ESRT) adalah protokol \textit{upstream} yang lebih banyak digunakan untuk mengirim event dibandingkan paket data. ESRT menggunakan pendekatan \textit{end-to-end} untuk menjamin \textit{reliability}. Pada ESRT tingkat pengiriman pada setiap node sensor bergantung pada tingkat \textit{reliable} di \textit{sink node} dan dengan status jaringan tersebut (terdapat kemacetan atau tidak). ESRT adalah protokol pertama yang menangani \textit{congestion control} dan \textit{reliability} sekaligus. 

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.6]{Gambar/event_detection}  
	\caption[Event Detection pada WSN]{Event Detection pada WSN} 
	\label{fig:event_detection} 
\end{figure} 

Pada ESRT setiap node sensor mendeteksi \textit{congestion} berdasarkan peningkatan \textit{buffer} lalu menambahkan N bit pada \textit{header} sebuah paket dan meneruskannya ke sink node. Berdasarkan paket yang diterima oleh \textit{sink node}, dapat diketahui keadaan dari jaringan dan juga \textit{reliability} suatu paket untuk menentukan jumlah paket yang telah berhasil diterima pada periode tertentu. ESRT menggunakan ACK untuk memastikan pengiriman data yang reliable. ESRT dapat berjalan saat \textit{sink node} melihat bahwa jumlah data yang diterima tidak sesuai dengan jumlah yang dikirimkan oleh node sensor.

\textbf{Reliable Multi Segment Transport (RMST)}

Reliable Multi Segment Transport (RMST) adalah protokol \textit{upstream} yang menjamin transfer paket yang reliable menggunakan \textit{selective NACK} untuk memastikan paket yang \textit{loss} dan mengirim ulang paket tersebut. Setiap node sensor pada RMST ini menyimpan data sementara (\textit{cache}). Data \textit{loss} dapat terjadi pada setiap node sensor. Dalam memulihkan data yang \textit{loss} RMST menggunakan pemulihan \textit{hop-by-hop}. Saat terjadi \textit{loss}, node sensor akan melakukan \textit{request} ke node sensor tetangganya. Jika data tidak ditemukan pada node tetangganya, maka NACK akan diteruskan ke node sensor sebelumnya hingga ke \textit{source node}. RMST ini menggunakan mekanisme \textit{timer-driven} untuk mendeteksi paket yang \textit{loss}. 

RMST dibuat untuk dapat berjalan diatas \textit{directed diffusion}. \textit{Directed diffusion} berarti protokol routing untuk memastikan \textit{reliability} untuk diaplikasikan. Pada RMST terdapat dua mekanisme yang dapat dilakukan yaitu mode \textit{caching} dan mode \textit{non caching}. Mode \textit{Caching} berarti node sensor yang berada di tengah dapat mendeteksi celah atau loss dan membuat request (NACK) ke node sebelumnya untuk memulihkan bagian yang hilang. Sedangkan pada mode \textit{non caching} berarti \textit{sink node} yang melakukan deteksi terhadap data yang hilang. Jadi sebenarnya RMST ini dapat dilakukan dengan mekanisme \textit{hop-by-hop} dan \textit{end-to-end}. Masalah dari RMST ini adalah tidak menangani \textit{congestion control}, penggunaan energi yang efisien, dan reliable pada aplication layer.


\textbf{Pump Slowly Fetch Quickly (PSFQ)}

Pump Slowly Fetch Quickly (PSFQ) adalah protokol yang mengadaptasi perbaikan atau pemulihan dengan \textit{hop-by-hop} saat terjadi data loss. PSFQ adalah protokol \textit{downstream}. Tujuan dari PSFQ adalah mencapai pengiriman data secara bolak-balik  \textit{reliable} dari \textit{sink node} ke node sensor dengan kecepatan yang relatif lambat, tapi memperbolehkan node sensor untuk melakukan pemulihan data yang hilang dari node tetangganya secara cepat. Protokol ini menggunakan mekanisme hop-by-hop dalam melakukan pengiriman ulang data yang hilang. Pada PSFQ terdapat tiga \textit{operation} yaitu \textit{pump}, \textit{fetch}, dan \textit{report}. 

Berikut adalah cara kerja PSFQ. Pertama, secara perodik dan perlahan \textit{sink node} melakukan \textit{broadcast} paket yang terdiri dari ID, panjang file, \textit{sequence number}, TTL, dan \textit{report bit} ke node sensor tetangganya sampai semua \textit{fragment} data dikirim semua. Kedua, node sensor akan memasuki mode \textit{fetch} saat \textit{gap} atau jarak pada \textit{sequence number} terdeteksi. Kemudian NACK akan dikirimkan kepada pengirim untuk memperbaiki \textit{fragment} yang hilang tersebut. Ketiga, dengan mekanisme \textit{hop-by-hop} \textit{fragment} yang hilang dapat dipulihkan. Protokol ini tidak menangani \textit{congestion} dan tidak menangani untuk satu paket yang hilang, karena saat melakukan \textit{pump} tidak hanya satu paket yang dikirimkan melainkan banyak paket sekaligus dan pemulihannya juga dilakukan semua pake yg dikirimkan pada saat tersebut.

\textbf{Asymmetric Reliable Transport (ART)}

Asymmetric Reliable Transport (ART) adalah protokol yang berbasis pada \textit{event} dan \textit{query reliability}. ART merupakan protokol \textit{bidirectional} pertama yang sudah mendukung \textit{congestion control}. Terdiri dari kumpulan node yang disebut \textit{essential node} yang tersebar pada suatu area untuk melakukan \textit{sensing} dan beberapa node yang disebut \textit{non-essential node} yang terlibat pada pengiriman data dan \textit{congestion control}.

\textbf{Price Oriented Reliable Transport Protocol (PORT)}

Price Oriented Reliable Transport Protocol (PORT) adalah protokol \textit{upstream} yang berbasis pada \textit{event reliability} dengan penggunaan energi seminimal mungkin. PORT mendukung mekanisme dengan energi yang efisien disertai \textit{congestion control}. Selain itu PORT juga adalah protokol yang mendukung komunikasi \textit{end-to-end}. PORT membutuhkan \textit{sink node} untuk mengatur aliran data. Kekurangannya adalah tidak ada pemulihan paket yang hilang.

\textbf{Delay Sensitive Transport (DST)}

Delay Sensitive Transport (DST) adalah tambahan dari ESRT. Tujuan dari DST adalah dicapai \textit{reliability} pada \textit{sink node}. Pada DST terdapat aturan \textit{Time Critical Event First} (TCEF).TCEF berarti data paket dengan diberikan prioritas untuk melakukan \textit{retransmission}. DST dapat bekerja dengan baik pada satu event, namun pada banyak event akan menjadi lebih kompleks.

Lebih singkat setiap protokol tersebut dapat dilihat pada Tabel~\ref{tab:protokol_reliable}
\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\label{tab:protokol_reliable}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\toprule
		Protokol & Arah & Tingkat & Mekanisme & Tipe ACK & Menangani Congestion & Energi Efisien \\

		\midrule
		GARUDA & Downstream & Packet & Hop-By-Hop & NACK & Tidak & Tidak\\
		ESRT & Upstream & Event & End-to-End & - & Ya & Ya\\
		RMST & Upstream & Packet & Hop-By-Hop & NACK & Tidak & Ya\\
		PSFQ & Downstream & Packet & Hop-By-Hop & NACK & Tidak & Tidak\\
		ART & Both & Event & End-to-End	 & - & Ya & Ya\\
		PORT & Upstream & Event & Hop-By-Hop & - & Ya & Ya\\
		DST & Upstream & Event & End-to-End & - & Tidak & Ya\\

		\bottomrule
		
	\end{tabular} 
	\caption{Tabel Perbandingan Protokol}
\end{table}

		\item \textbf{Mempelajari PreonVM.}\\
		{\bf Status :} Baru ditambahkan pada semsester ini.\\
		{\bf Hasil :} 

\textbf{PreonVM}

PreonVM adalah virtual machine (VM) yang dibuat oleh VIRTENIO untuk sistem komputer yang dirancang khusus (\textit{embedded system}) dengan sumber daya yang terbatas. PreonVM dapat digunakan pada node sensor jenis Preon32. PreonVM dibuat sangat optimal dengan tidak dibutuhkannya sistem operasi tambahan dan berjalan langsung pada \textit{microprocessor}. Dengan PreonVM ini \textit{developer} dapat membuat aplikasi dengan mudah pada Bahasa Java yang mengumpulkan data dari sensor dan mengontrol aktuator. API pada PreonVM mendukung antarmuka radio sesuai dengan IEEE 802.15.4 dan AES encryption pada perangkat kerasnya. 
		
PreonVM memiliki fitur sebagai berikut:
\begin{itemize}
	\item Aplikasi dibangun dengan Bahasa Pemrograman Java
	\item Mendukung semua tipe data pada Java seperti char, byte, int, long, float atau double
	%Garbage collection adalah program yang berjalan pada java virtual machine untuk menyingkirkan object yang tidak dibutuhkan pada aplikasi.
	\item \textit{Garbage collection} dengan \textit{memory defragmentation}
	\item Mendukung \textit{exception handling}, stack dan array multidimensi
	\item Terdapat \textit{system properties} untuk mengatur aplikasi
	\item Tidak membutuhkan sistem operasi tambahan
	\item Mendukung threads termasuk synchronized, Object.wait, Object.notify, Object.notifyAll, Thread.sleep, Thread.interrupt
\end{itemize}

Kelebihan yang dimiliki oleh VIRTENIO ini adalah \textit{object-oriented programming} dengan Bahasa Pemrograman Java. VIRTENIO menyediakan virtual machine sebagai sistem operasi yang inovatif untuk modul Preon32. Dengan menggunakan virtual machine, aplikasi dapat berdiri sendiri pada arsitektur yang dibuat. Dengan demikian aplikasi Java yang dibuat dapat dijalankan pada aristektur yang berbeda tanpa harus modifikasi. Gambar~\ref{fig:PreonVM} menunjukan ilustrasi penggunaan virtual machine pada berbagai perangkat. 

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/PreonVM}  
	\caption[Penggunaan virtual machine pada perangkat yang berbeda]{Penggunaan virtual machine pada perangkat yang berbeda} 
	\label{fig:PreonVM} 
\end{figure} 

Virtual machine juga membatu memisahkan proses pengembangan perangkat keras dengan aplikasi perangkat lunak. Program aplikasi dikembangan dengan antarmuka yang abstrak dan tidak berubah. Sebagai tambahan, virtual mesin berjalan optimal untuk aplikasi kecil pada 8-bit sampai 32-bit microprocessor dengan 8 Kbyte RAM dan 128 Kbyte Flash.  

\textbf{Preon32}

Preon32 adalah salah satu jenis node sensor. Preon32 menggunakan PreonVM sebagai sistem operasi. Preon32 versi umum memiliki 5 jenis sensor pada sebuah board. Sensor yang ada pada Preon32 ini antara lain sensor suhu (temperature), sensor cahaya, sensor kelembapan udara (humidity), sensor untuk mengukur tekanan udara (barometer), dan sensor getaran. Pada versi tambahan Preon32 dapat dilengkapi dengan sensor untuk mendeteksi medan magnet (magnetometer), dan gyroscope. Semua jenis sensor tersebut dapat diatur melalui PreonVM dan pemrograman dapat dilakukan dengan Bahasa Pemrograman Java. Gambar~\ref{fig:Preon32board} adalah board dan sensor-sensor pada Preon32.

\begin{figure} [H]
	\centering  
	\includegraphics[scale=0.7]{Gambar/Preon32board}  
	\caption[Preon32 Board]{Preon32 Board} 
	\label{fig:Preon32board} 
\end{figure} 

Preon32 ini dapat diaplikasikan pada berbagai hal seperti:
\begin{enumerate}
	\item \textit{Home Automation} yang digunakan untuk mengintegrasikan berbagai sistem pada rumah, \textit{monitoring area}, dan navigasi.  
	\item Platform untuk membantu penelitian
	\item Implementasi aplikasi pada jaringan nirkabel
\end{enumerate}

		\item \textbf{Mempelajari class library Java Virtual Machine Preon32}\\
		{\bf Status :} Ada sejak rencana kerja skripsi.\\
		{\bf Hasil :} 
		
Preon32 mengunakan PreonVM sebagai Virtual Machine yang dikeluarkan oleh Virtenio. Class library pada Virtenio VM ini dibagi menjadi beberapa package utama diantaranya \textbf{\textit{Radio Packages}}, \textbf{\textit{Route Packages}}, \textbf{\textit{Other Virtenio Packages}}, dan \textbf{\textit{Java Related Packages}}. Tabel~\ref{tab:radio_packages}, sampai Tabel~\ref{tab:java_packages} berisi package yang terdapat pada setiap package utama.
		
\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\label{tab:radio_packages}
	\begin{tabular}{|c|c|}
		\toprule
		Package & Deksripsi \\

		\midrule
		com.virtenio.radio & Paket yang berisi kelas terkait radio \\
		ESRTcom.virtenio.radio.ieee\_802\_15\_4  & Paket yang berisi kelas terkait IEEE 802.15.4 \\

		\bottomrule
		
	\end{tabular} 
	\caption{Tabel Radio Packages}
\end{table}

\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\label{tab:route_packages}
	\begin{tabular}{|p{6cm}|p{10cm}|}
		\toprule
		Package & Deksripsi \\

		\midrule
		com.virtenio.route.aodv & Paket yang berisi kelas terkait AODV (Ad Hoc On Demand Vector) Routing \\

		\bottomrule
		
	\end{tabular} 
	\caption{Tabel Route Packages}
\end{table}

\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\label{tab:other_packages}
	\begin{tabular}{|p{6cm}|p{10cm}|}
		\toprule
		Package & Deksripsi \\

		\midrule
		com.virtenio.driver & Paket yang berisi drivers untuk berbagai perangkat \\
		com.virtenio.driver.adc  & Paket yang berisi kelas ADC driver \\
		com.virtenio.driver.atmodem & \\
		com.virtenio.driver.button & Paket yang berisi kelas button driver \\
		com.virtenio.driver.can & Paket yang berisi kelas CAN driver \\
		com.virtenio.driver.cpu & Paket yang berisi kelas CPU driver \\
		com.virtenio.driver.device & Paket yang berisi kelas divice driver \\
		com.virtenio.driver.device.at86rf212 & Paket yang berisi driver untuk perangkat ATR86RF212 \\
		com.virtenio.driver.device.at86rf231 & paket yang berisi driver untuk perangkat AT86RF231 \\
		com.virtenio.driver.flash & Paket yang berisi kelas Flash driver  \\
		com.virtenio.driver.gpio & Paket yang berisi kelas GPIO device driver \\
		com.virtenio.driver.i2c & Paket yang berisi kelas I2C device driver \\
		com.virtenio.driver.irq & Paket yang berisi kelas IRQ device driver \\
		com.virtenio.driver.led & Paket yang berisi kelas LED device driver \\
		com.virtenio.driver.lin & Paket yang berisi kelas LIN device driver\\
		com.virtenio.driver.onewire & Paket yang berisi kelas OneWire device driver\\
		com.virtenio.driver.pwm & Paket yang berisi kelas PWM (pulse-width modulation) device driver\\
		com.virtenio.driver.ram & Paket yang berisi kelas FRAM device driver \\
		com.virtenio.driver.rtc & Paket yang berisi kelas untuk pengaturan jam secara real-time, dan real-counter device driver \\
		com.virtenio.driver.spi & Paket yang berisi kelas SPI (Serial Peripheral Interface) device driver \\
		com.virtenio.driver.sw & Paket yang berisi kelas switch device driver \\
		com.virtenio.driver.timer & Paket yang berisi kelas hardware timer device driver\\
		com.virtenio.driver.usart & Paket yang berisi USART device driver\\
		com.virtenio.driver.watchdog & Paket yang berisi \\
		com.virtenio.io & Paket Virtenio VM yang berisi IO \\
		com.virtenio.lib & Paket Virtenio VM yang berisi pengaturan classlib\\
		com.virtenio.misc & Paket tambahan Virtenio VM \\
		com.virtenio.net & \\
		com.virtenio.vm & \\
		com.virtenio.vm.event & Sistem event pada Virtenio VM untuk menangani event asynchronous dan synchronous \\
		
		\bottomrule
	\end{tabular} 
	\caption{Tabel Other Virtenio Packages}
\end{table}

\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\label{tab:java_packages}
	\begin{tabular}{|c|c|}
		\toprule
		Package & Deksripsi \\

		\midrule
		java.io & Paket Java IO \\
		java.lang  & Paket Java lang \\
		java.lang.annotation & Paket Annotation pada Java\\
		java.lang.ref & \\
		java.nio & \\
		java.nio.channels & \\
		java.text & Paket Java Text \\
		java.util & Paket Java Utility yang berisi collection\\
		java.util.regex & Paket Java Regular Expression\\
		
		\bottomrule
	\end{tabular} 
	\caption{Tabel Java Related Packages}
\end{table}	
		
		\item \textbf{Melakukan analisis terhadap protokol transfer yang \textit{reliable} pada \textit{Wireless Sensor Network} untuk digunakan dalam membangun aplikasi transfer data}\\
		{\bf Status :} Baru ditambahkan pada semester ini \\
		{\bf Hasil :} 
		
Tidak semua protokol pengiriman data pada WSN mendukung pengiriman data yang \textit{reliable}. Setiap protokol memiliki spesifikasi yang berbeda-beda pada arah \textit{retransmission}, data yang dikirim, mekanisme dan \textit{acknowledge} yang digunakan. Untuk memastikan data yang \textit{reliable} dilakukan pengiriman ulang (\textit{retransmission}) data yang hilang atau \textit{loss}. Data yang dikirim ulang ini dapat berasal dari hasil \textit{sensing} node sensor atau data dari \textit{base station} seperti perintah atau \textit{method} untuk melakukan sesuatu. 

Pada skripsi ini data yang dikirim ulang adalah data hasil \textit{sensing} sehingga protokol yang digunakan adalah protokol dengan arah pengiriman \textit{upstream}. Aplikasi yang dibangun ini juga menangani pengiriman data yang \textit{reliable}. Data yang didapat oleh node sensor dapat diteruskan ke node tetangganya sebelum sampai ke tujuan akhir yaitu \textit{base station}. Berdasarkan Tabel~\ref{tab:protokol_reliable} terdapat beberapa protokol yang diadaptasi untuk membuat aplikasi transfer data ini.

Aplikasi transfer data yang dibangun ini mengadaptasi beberapa cara yang yang terdapat pada protokol RMST untuk menangani \textit{reliability} transfer data dari node sensor ke \textit{base station}. Aplikasi dibangun menggunakan mekanisme \textit{hop-by-hop} dengan bantuan ACK dalam memastikan data sampai ke node tetangganya. Dengan mekanisme \textit{hop-by-hop} akan lebih cepat untuk mengirimkan ulang data yang \textit{loss}. Jika dibandingan dengan mekanisme \textit{end-to-end}, maka pengiriman ulang akan dilakukan jika \textit{base station} menemukan data yang \textit{loss}. Jika ingin meminta data yang \textit{loss} dengan mekanisme \textit{end-to-end} maka \textit{base station} harus meminta data kepada node sebelumnya hingga ke node awal. Sehingga mekanisme \textit{end-to-end} lebih banyak meneruskan data ke node lain data dibandingan dengan mekanisme \textit{hop-by-hop}.

Dengan mekanisme \textit{hop-by-hop}, saat salah satu node mengirimkan data ke node tetangganya, node pengirim akan menunggu ACK dari node penerima. Saat menunggu ACK dari node tetangganya ini digunakan juga mekanisme \textit{timer-driven}. Dengan menggunakan mekanisme \textit{timer-driven} ini, waktu menunggu ACK dapat dibatasi. Jika sudah melewati batas waktu menunggu ACK tersebut, maka data akan dianggap tidak diterima oleh penerima dan pengirim akan mengirimkan ulang data. Saat melakukan pengiriman ulang data ini bisa saja terjadi pengulangan data yang diterima. Jika ini terjadi maka digunakan \textit{sequence number} untuk memastikan urutan data.

\textbf{Analisis Aplikasi Pengiriman Data}

Pada skripsi ini dibangun aplikasi yang dapat melakukan transfer data dari node sensor ke base station. Aplikasi ini digunakan untuk mengetahui keadaan suatu tempat dengan bantuan node sensor. Aplikasi ini memiliki beberapa fungsi. Fungsi utama pada aplikasi ini adalah untuk melakukan transfer data dari setiap node sensor dan memastikan pengiriman data yang \textit{reliable}. Fungsi lain pada aplikasi ini dijelaskan menggunakan diagram \textit{use case} pada Gambar~\ref{fig:usecase} dan skenario pada Tabel~\ref{tab:skenario1} sampai Tabel~\ref{tab:skenario4}. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{Gambar/usecase}
	\caption{Diagram \textit{use case} aplikasi data transfer pada WSN}
	\label{fig:usecase}
\end{figure}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm}|p{10cm}|}
    \hline
        Nama & Melakukan sinkronisasi waktu\\
    \hline
    \hline
        Deskripsi & Melakukan sinkronisasi waktu untuk mengetahui kapan data dikirim dari node sensor dan diterima oleh \textit{base station}. \\
    \hline
        Aktor & Pengguna \\
    \hline
        Pre-kondisi & Aplikasi dimulai \\
    \hline
        Alur Skenario Utama & 
        \begin{enumerate}
            \item Sistem memuat aplikasi.
            \item Sistem menampilkan menu untuk dipilih pengguna.
            \item Pengguna memilih menu sinkronisasi waktu.
            \item Sistem melakukan sinkronisasi waktu pada setiap node sensor.
            \item Sistem menampilkan menu.
        \end{enumerate}\\
    \hline
    \end{tabular}
    \caption{Tabel skenario melakukan sinkronisasi waktu.}
    \label{tab:skenario1}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm}|p{10cm}|}
    \hline
        Nama & Menjalankan fungsi untuk \textit{sensing}\\
    \hline
    \hline
        Deskripsi & Pengguna menjalankan fungsi ini untuk membuat node sensor melakukan sensing.\\
    \hline
        Aktor & Pengguna \\
    \hline
        Pre-kondisi & Sudah dilakukan sinkronisasi waktu pada setiap node sensor\\
    \hline
        Alur Skenario Utama & 
        \begin{enumerate}
            \item Sistem memuat aplikasi.
            \item Sistem menampilkan menu untuk dipilih pengguna.
            \item Pengguna memilih menu untuk \textit{sensing}.
            \item Sistem memerintahkan node sensor untuk melakukan \textit{sensing}.
            \item Sistem mendapatkan data dari setiap node sensor.
        \end{enumerate}\\
    \hline
    \end{tabular}
    \caption{Tabel skenario menjalankan fungsi untuk \textit{sensing}.}
    \label{tab:skenario2}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm}|p{10cm}|}
    \hline
        Nama & Mendapatkan Data\\
    \hline
    \hline
        Deskripsi & Setelah sensor melakukan sensing dan mendapatkan data, data tersebut dikirimkan kepada pengguna\\
    \hline
        Aktor & Pengguna \\
    \hline
        Pre-kondisi & Sistem sudah melakukan \textit{sensing} dan data hasil \textit{sensing} sudah didapatkan node sensor \\
    \hline
        Alur Skenario Utama & 
        \begin{enumerate}
            \item Sistem mendapatkan semua data hasil \textit{sensing}.
            \item Sistem mengirimkan data hasil \textit{sensing} kepada base station (pengguna).
        \end{enumerate}\\
    \hline
    \end{tabular}
    \caption{Tabel skenario mendapatkan data.}
    \label{tab:skenario3}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm}|p{10cm}|}
    \hline
        Nama & Melihat Data Hasil Sensing\\
    \hline
    \hline
        Deskripsi & Pengguna dapat melihat data hasil sensing berupa tabel\\
    \hline
        Aktor & Pengguna \\
    \hline
        Pre-kondisi & Data sensing sudah didapatkankan oleh base station \\
    \hline
        Alur Skenario Utama & 
        \begin{enumerate}
        	\item Pengguna memulai aplikasi.
        	\item Sistem menampilkan menu untuk dipilih pengguna.
        	\item Pengguna memilih fungsi untuk melihat data hasil sensing.
            \item Sistem menampilkan data hasil sensing tersebut berupa tabel.
        \end{enumerate}\\
    \hline
    \end{tabular}
    \caption{Tabel skenario melihat data hasil sensing.}
    \label{tab:skenario4}
\end{table}

Aplikasi yang dibangun digunakan pada arsitektur flat dengan multi-hop (Gambar~\ref{fig:flat}) dan arsitektur hierarki dengan multi-hop(Gambar~\ref{fig:cluster_multi}). Untuk setiap arsitektur memiliki cara yang berbeda dalam mengirim data hingga sampai ke \textit{base station} termasuk cara mengetahui dan memulihkan paket yang hilang.

\textbf{Arsitektur Flat}

Pada arsitektur flat tidak terdapat \textit{cluster head}. Setiap node sensor yang melakukan \textit{sensing} akan mengirimkan data dengan cara meneruskan data ke node sensor tetangganya. Node sensor tetangganya tersebut yang akan meneruskan data ke node sensor lain hingga sampai ke base station. Berikut adalah urutan langkah dalam melakukan transfer data pada arsitektur flat dengan \textit{multi-hop} dan cara menangani data yang hilang.

\begin{enumerate}
	\item Node sensor melakukan \textit{sensing}.
	\item Node sensor mendapatkan data-data hasil \textit{sensing}.
	\item Data yang didapat ini berisi waktu kapan data diambil dan data utama hasil \textit{sensing}.
	\item Node sensor yang sudah mendapatkan data akan meneruskan data tersebut ke node sensor tetangganya.
	\item Node sensor yang menerima data dari node sensor sebelumnya akan mengirimkan ACK kepada node sensor sebelumnya sebagai tanda data telah diterima.
	\item Dalam menunggu ACK dari node sensor lain, sebuah node sensor menggunakan \textit{timer} untuk membatasi waktu menunggu.
	\item Jika sudah melewati batas waktu dan ACK belum didapatkan maka secara otomatis data akan dikirimkan lagi.
	\item Pengiriman ulang ini dilakukan sampai ACK diterima oleh pengirim.
	\item Dengan cara yang sama node sensor menggunakan ACK saat akan mengirim ke \textit{base station}.
\end{enumerate}

\textbf{Arsitetur Hierarki}

Sedikit perbedaan pada arsitektur hierarki dengan arsitektur flat adalah adanya \textit{cluster head}. \textit{Cluster head} ini yang bertugas untuk mengumpulkan data dari node sensor pada satu \textit{cluster} dan meneruskan data tersebut ke \textit{base station}. Berikut adalah urutan langkah dalam melakukan transfer data pada arsitektur hierarki dan cara menangani data yang hilang.

\begin{enumerate}
	\item Node sensor melakukan \textit{sensing}.
	\item Node sensor mendapatkan data-data hasil \textit{sensing}.
	\item Data yang didapat ini berisi waktu kapan data diambil dan data utama hasil \textit{sensing}.
	\item Node sensor yang menerima data dari node sensor sebelumnya akan mengirimkan ACK kepada node sensor sebelumnya sebagai tanda data telah diterima.
	\item Dalam menunggu ACK dari node sensor lain, sebuah node sensor menggunakan \textit{timer} untuk membatasi waktu menunggu.
	\item Jika sudah melewati batas waktu dan ACK belum didapatkan maka secara otomatis data akan dikirimkan lagi.
	\item Pengiriman ulang ini dilakukan sampai ACK diterima oleh pengirim.
	\item Node pada sebuah \textit{cluster} akan mengirimkan data ke satu \textit{cluster head}.
	\item \textit{Cluster head} yang akan meneruskan data ke \textit{base station}.
\end{enumerate}

		\item \textbf{Menulis dokumen skripsi 1}\\
		{\bf Status :} Ada sejak rencana kerja skripsi.\\
		{\bf Hasil :} 
		
		Dokumen skripsi 1 yang telah dibuat adalah Bab 1, Bab 2, dan sebagian Bab 3. Bab 1 meliputi Latar Belakang, Rumusan Masalah, Tujuan, Batasan Masalah, Metodologi, dan Sistematika Pembahasan. Bab 2 meliputi studi literatur mengenai \textit{Wireless Sensor Network}, Reliable Data Transfer di WSN, dan PreonVM. Sebagian Bab 3 yang sudah dikerjakan meliputi analisis pengiriman data dari node sensor ke base station pada WSN, analisis terhadap protokol transfer yang \textit{reliable} pada \textit{Wireless Sensor Network} untuk digunakan dalam membangun aplikasi transfer data, dan analisis aplikasi pengiriman data pada WSN.

	\end{enumerate}


\section{Pencapaian Rencana Kerja}
Langkah-langkah kerja yang berhasil diselesaikan dalam Skripsi 1 ini adalah sebagai berikut:
\begin{enumerate}
\item Mempelajari permasalahan dari topik skripsi ini.
\item Melakukan studi literartur mengenai \textit{Wireless Sensor Network}.
\item Mempelajari protokol transfer data yang biasa pada \textit{Wireless Sensor Network}.
\item Melakukan analisa terhadap protokol transfer yang \textit{reliable} pada \textit{Wireless Sensor Network} untuk digunakan dalam membangun aplikasi transfer data.
\item Menulis dokumen skripsi 1.
\end{enumerate}


\section{Kendala yang Dihadapi}
%TULISKAN BAGIAN INI JIKA DOKUMEN ANDA TIPE A ATAU C
Kendala - kendala yang dihadapi selama mengerjakan skripsi :
\begin{itemize}
	\item Terlalu banyak godaan berupa hiburan (game, film, dll).
\end{itemize}

\vspace{1cm}
\centering Bandung, \tanggal\\
\vspace{2cm} \nama \\ 
\vspace{1cm}

Menyetujui, \\
\ifdefstring{\jumpemb}{2}{
\vspace{1.5cm}
\begin{centering} Menyetujui,\\ \end{centering} \vspace{0.75cm}
\begin{minipage}[b]{0.45\linewidth}
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013 \\
\vspace{2cm} Nama: \pembA \\ Pembimbing Utama
\end{minipage} \hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
\vspace{2cm} Nama: \pemB \\ Pembimbing Pendamping
\end{minipage}
\vspace{0.5cm}
}{
% \centering Bandung, \makebox[0.5cm]{\hrulefill}/\makebox[0.5cm]{\hrulefill}/2013\\
\vspace{2cm} Nama: \pembA \\ Pembimbing Tunggal
}
\end{document}

